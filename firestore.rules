
/**
 * @file firestore.rules
 * @description Firestore Security Rules for a news application.
 *
 * @version 1.1
 *
 * @philosophy
 * This ruleset implements a robust security model balancing user privacy with public content accessibility.
 * The core philosophy is based on strict user ownership for personal data and a clear separation between private
 * user-generated content and publicly available application content.
 *
 * @structure
 * - /users/{userId}: Contains user profile data. Each user can only access their own document.
 * - /users/{userId}/bookmarks/{bookmarkId}: A private subcollection for a user's bookmarked articles. Access is restricted to the owner.
 * - /users/{userId}/drafts/{draftId}: A private subcollection for a user's article drafts. Access is restricted to the owner.
 * - /articles/{articleId}: A public collection of news articles. Anyone can read, but only authors can write.
 * - /authors/{authorId}: A public collection of author profiles. Currently read-only.
 * - /tags/{tagId}: A public collection of tags. Currently read-only.
 *
 * @decisions
 * - User Privacy: A user's profile, bookmarks, and drafts are strictly confined to their own access.
 * - Public Content: Articles, Authors, and Tags are in top-level collections, making them publicly readable.
 * - Content Ownership: Write access to articles is controlled by the `authorId` field.
 * - Secure Defaults: Collections like `authors` and `tags` have writes disabled by default.
 *
 * @denormalization
 * The `Article` entity includes a denormalized `authorId` field. This is critical for security, as it allows rules to efficiently and securely verify ownership for write operations without needing to perform costly `get()` calls to other collections.
 *
 * @segregation
 * Private user data (bookmarks, drafts) is structurally segregated into subcollections under the user's document (`/users/{userId}/...`). This is a more secure and performant pattern than storing private and public data in the same collection.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // -------------------------------------------------------------------------
    // Helper Functions
    // -------------------------------------------------------------------------

    /**
     * isSignedIn
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * isOwner
     * Checks if the authenticated user's UID matches the provided userId.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * isExistingOwner
     * Checks if a document exists and if the authenticated user is the owner.
     * CRITICAL for safe update and delete operations.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    // -------------------------------------------------------------------------
    // User Data Rules
    // -------------------------------------------------------------------------

    /**
     * @description Controls access to user profile documents.
     * @path /users/{userId}
     * @principle Restricts access to a user's own data tree and prevents user enumeration.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);

      /**
       * @description Controls access to a user's private bookmarks subcollection.
       * @path /users/{userId}/bookmarks/{bookmarkId}
       * @principle Enforces strict ownership for all operations on a user's private subcollection.
       */
      match /bookmarks/{bookmarkId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.userId == userId;
        allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
        allow delete: if isExistingOwner(userId);
      }
      
      /**
       * @description Controls access to a user's private drafts subcollection.
       * @path /users/{userId}/drafts/{draftId}
       * @principle Enforces strict ownership for all operations on a user's private subcollection.
       */
      match /drafts/{draftId} {
        allow read, write: if isOwner(userId);
      }
    }

    // -------------------------------------------------------------------------
    // Public Content Rules
    // -------------------------------------------------------------------------

    /**
     * @description Controls access to news articles. Data is public to read, but writes are restricted to authors.
     * @path /articles/{articleId}
     * @principle Implements a "Public Read, Owner-Only Write" pattern using the 'authorId' field for authorization.
     */
    match /articles/{articleId} {
      allow get: if true;
      allow list: if isSignedIn() && request.query.where[0][2] == request.auth.uid;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.authorId == request.auth.uid;
      allow delete: if isSignedIn() && resource.data.authorId == request.auth.uid;
    }

    /**
     * @description Controls access to author profiles. Data is public to read.
     * @path /authors/{authorId}
     * @principle Provides public read access but disables writes as a secure default.
     */
    match /authors/{authorId} {
      allow get: if true;
      allow list: if true;
      // CRITICAL: Cannot implement owner-only writes. The 'Author' entity is missing an 'ownerId' or 'creatorId' field.
      allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Controls access to article tags. Data is public to read.
     * @path /tags/{tagId}
     * @principle Provides public read access but disables writes as a secure default.
     */
    match /tags/{tagId} {
      allow get: if true;
      allow list: if true;
      // CRITICAL: Cannot implement owner-only writes. The 'Tag' entity is missing an 'ownerId' or 'creatorId' field.
      allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }
  }
}
